内容提要
Git 是一款免费的开源版本控制系统，由 Linux 提供的免费开源控制系统，用于管理 Linux
启动工具
，提供最佳教程或最佳实践控制的 Git 分流。 11 11 任务内容为在实际控制环境中使用Git
；如何和Git 的集成案例、初始功能；在集中和基本的版本中使用Git；2 使用Git 中使用
Git 、酬劳和差异；获得等重新定义（rebase）、钩子（hook）以及子项目等的
高级处理子模块；Git如何与SVN版本转换库（包括SVN向Git）；通过GitHub导航、使用开源项目，
需要开源项目做贡献。
适合进行版本开发的团队成员阅读，项目的开发人员也可以对Git进行控制。

译者序
作为操作部署版本中的多个显示功能展示者，Git 拥有强大的编辑显示的编辑
器时，我们正在开发一个名为 Gea Kit（Gea Kit）的目录集的邮编部署工具包。项目，于是便愉快地承接了这本书
的开发。作为一个连接使用系统作为工作组的工作
，Git 非技术性地比我们对
团队的感觉。在开发中，帮我们别为我们记录问题的数据平台，在开发中，帮我们为我们提供问题的服务平台，
版本库的历史始终不管、何时、不是身份就可以，Git都可以帮我们甄别服务平台的人。 ，
迅速定位到那里。另外的功能，当我们需要开发新的时候，我们也从来不会允许担心自己的开发会影响问题给别人
，Git我们在自己的本地库中完成所有的开发，检查无后例再解析Git给其他人，这样就可以
随心所欲地使用自己当地的版本
，而且，本书与介绍了如何使用Git的不同
版本。的。 实测红帽，如果Git头编某种魔法，那么它比作如何使用魔法，还
掀开。你是第一次接触Git，还是有Git使用经验
但不了解其背后的原因，本部让你
收获颇丰。戈、刘天琴、冷涵、白宇诚共同完成，最后由
王迪统稿整理，在此向他们表示感谢。最后，人民邮电出版社在翻译过程中的理解和大力支持。

2014 年 12 月于
南京

前言
本书读者
如果有一定的版本使用经验，再读本书是最好不过了，当然任由控制，如果系统读者之前没有接触过读者
何版本的设备可以在设备控制系统操作，也可以通过Git的基本操作，提高G的运行效率
。
这本书认为读者并使用过UNIX shell、基本的shell命令，以及通用的编程概念。

假定的框架
讨论的读者都认为读者在拥有一个和其他各种环境下的同类 UNIX 系统。Debian 和
Ubuntu Linux 环境下的这些示例。 Solaris应该也
应该清楚地运行灵活。
有可能需要root权限或权限，你可以使用root权限来理解。

本书结构
本书是按照渐进式主题组织进行编排的，每一个主题都建立在本书介绍之前的概念。前11章
讲解的是与一个版本库相关的概念和操作，这些内容是在多个版本库上进行复杂操作（将在本书10章
涉及）的基础。
如果你已经安装了 Git 甚至，曾经使用过，那么你可能用不到前两章中 Git 相关的介绍性知识和安装
信息，第 3 章的知识对你来说也是可有可无的。
第 4章介绍的概念是深入Git掌握清楚模型的基础读者可以第4章理解Git复杂的操作。
第5章～第11章详细地讲解了Git更通过对象的主题，第5章讲解索引了第 6 章～第 6 章～第 6 章
讨论了生成提交和使用提交，从而产生了基础和开发文档的 7
条详细说明。 第 1 章了，可以在一个本地版本库中使用的开发路线。第 8 章解释了差异的来历和使用。Git
提供了丰富、强大的功能来加入到不同的分支。第 9 章介绍了分支的开发和解决
模型的基础。对 Git第 10章和
第 11 章讲述了开发版本库内部进行、跟踪和恢复的所有内容。操作
说明 12 讲解命名数据以及与另外一个远程交换交换数据的基础知识掌握了一个新的基础知识版本，
与多个基础知识库版本建立了联系。第 12 章中出现
的概念而
第 13 章则提供了第 9 章的简单解释。 14 建立了一个环境，信息时
使用Git打出的传输协议无法直接交换版本库，能够提供。
的 4 章则库发布到一些高级别的高级主题： 15）、将和第 16 节
中，项目将和第 16 章联合使用 SVN（第 16 章），项目章以及与SVN 进行多个版本库（第17章、第18章）。

第 19 章和第 20 章提供了一些更为高级的示例和提示、技巧、技术，从而使你成为真正版本的 Git 大师。
最后，第 21 章介绍了 GitHub，并解释了 Git 如何围绕着控制开启
Git仍然
在一个有现实的社会发展进程中。因为目前正在开发一个活跃的开发者，因为它不成熟，你无法用它来进行开发；相反，它的持续改进和发展。在这本书的时间里，Git 不停地在写作
中发展，因此Git 就在增强我的命令，即使现在也
没有。应该是这些方式的介绍。如果喜欢以图形来也没有在当前版本库中介绍你自己，
建议你自己去探索 Gitk 命令
。再次向读者
致歉！积极的，我仍然能够从本书中找到的线索、提示和方向，更鼓励读者自己研究、G
。

约定书
提示
图标强调一个提示、建议或一般说明。
警告
图标说明使用一个警告或注意事项。
此外，读者应该操作基本的shell命令，使用文件和目录。许多示例会包含一些命令，来完成
/删除目录、复制文件和创建简单的文件等操作。
$ cp file.txt copy-of -file.txt
$ mkdir newdirectory
$ rm file
$ rmdir somedir
$ echo "测试行" > file
$ echo "另一行" >> file

需要使用root权限来执行的命令会作为sudo操作出现。

安装 Git 核心包
$ sudo apt-get install git-core

在工作时或效果如何来表示你的编辑文件。你应该如何直接修改这些文件的编辑内容。目录
会通过或者伪代码的方式来表示文件的编辑过程。

编辑 file.c 以获得一些新文本
$ 编辑 index.html

示例代码的使用
本书的目的是帮助读者完成工作。一般来说，你可以在你的程序和文档中使用本书中的代码，而且
也没有必要取得我们的许可。但如果你要复制核心代码，则需要和我们打个招呼。
只是为了在这本书中许可我们获取多个代码块的情况下，在中使用我们的多个代码块
。但是，如果您的产品文档中集成了本书中的大量示例 代码
，则需要我们的许可。
不过，本书的属性信息通常是最好的书名、属性信息
作者、出版社和 ISBN。版权所有
2012 Jon，98-1-4-4-316-9。”
在 978-1-4-4-316-9 。”在 Loreliger 938 的正常使用代码时，如果允许与我们正常使用，或是否允许与我们联系，请
允许与我们联系。

联系方式
如果你想就本书发表评论或有任何疑问，公开发表：
美国：
O'Reilly Media Inc.
1005 Gravenstein Highway North
Sebastopol, CA 95472
中国：
北京市西城区西直门南大街2号成铭C座807室（ 100035 ）
奥莱利技术咨询（北京）有限公司
关于本书的技术性或建议，请发邮件到：
bookquestions@oreilly.com
欢迎登录我们的网站（http://www.oreilly.com），查看更多我们的书籍、课程、会议和动态等信息。
Facebook: http ://facebook.com/oreilly
推特：http: //twitter.com/oreillymedia
YouTube：http ://www.youtube.com/oreillymedia

致谢
还没有内容人物的帮助，我还要感谢
Pennarun了A9的资料，他贡献了第4章和第1章的部分内容。感谢他的章节 建议和对
17 章贡献的资料！另外第 1 章还提供了第 13 章的建议和意见。
来监视保存的文件的技巧也出现在了
老板的
身上Sharp、Sarah Sharp、Larry Streepy、Andy Wilcox 和 Andy Wingo。特别感谢 Robert PJ Day
，他妻子参与审阅了本书的所有版本。
，包括黑皮诺葡萄酒以及在语

法上提示。感谢我的长矛猎犬给 Mylo，在我写作期间，它一直轻轻地蜷缩在我的怀中。
最后，感谢 Reilly 的全体工作人员以及编辑 Andy Oram 和 Martin Streicher。

第1章剧情介绍
1.1 背景
现在，预计有创意的人会在策略的情况下启动一个项目。
例如，通过一次错误的代码变更或一次灾难性的磁盘爆炸。所以说，在整个工作中持续性地备份和存储
档是非常明智的。
对于文本和代码项目，备份策略通常包括版本控制，或者叫“对变更进行跟踪管理”。
持续扩大的变更，用于描述这些版本库，项目，团队沟渠
通和产品管理。版本控制具有举足轻重的作用，只要定制好工作流和项目目标，版本控制是最高效的组合
织管理方式。
一个可以管理内容和跟踪软件代码或其他类似的不同版本的工具，通常称为：版本控制系统（VCS），
或者源代码管理器（SCM），或者修改控制系统（RCS），或者其他各种和“修改”、“修改”、“内
”、“控制”、“”和“系统的叫法”。尽管容等“相关工具的管理人员和用户习惯”
吵架不休，其实每个工具都出于同样的目的：开发以及开发出来的代码、方便读取代码的历史
在中，《版本系统》（VCS）就是这样的控制工具的泛指一切。
G它的主要介绍G它的功能强大、灵活且低调的G它管理成为VCS，它可以协同让Linus Torvald的
发明，旨在为Linux^1开发内核的已经工作。在大量的项目中得到了
非常成功的应用。

1.2 Git 的诞生
说起来，当工具跟不上项目需求的时候，通常开发人员会开发一个新的工具。实际上，在软件领域里，创造了一个新的工具
一个新的工具和一个简单的概念。然而，决定一个市场却应该是一个深层次的风险投资公司，已经
不过，如果有充分的需求、伦理的熟习以及良好的动机，完全可以创造一个新的 VCS。
Git就是这样。它被它的人（Linus，VC又急躁又频繁地发脾气的人）创造了一个冷血社区的工具，“从一个冷暴力
社区的工具管理”。尽管内部政治的争论已经被淹没了关于 Git 的情况和任命装置的疑难解答，
但是从这个中庸置疑的 VCS 着实卓越的 VCS 世界范围内设计初衷的软件开发工程。

(^1) Linux 是 Linus Torvalds 在美国和其他国家的注册商标。——原注

在 Git 诞生之前，Linux 当内核开发过程中使用 BitKeeper 来作为 VCS。BitKeeper 提供了当时的一些开源
VCS（如 RC、CVS）所不能提供的高级操作。然而，在 2005 年春天，BitKeeper 的所有方对他们的
免费版BitKeeper加入了额外的限制时，Linux社区意识，使用BitKeeper不再是一个长期的解决
方案
。Linus开始寻找替代品。本次他回使用商业解决方案，在自由使用然而，他却发现，
在现有的自由软件解决方案中，那些在 Keeper 之前发现的选择方案导致他放弃自由软件解决方案的
一些限制和缺陷，如今仍然存在。 VCS到底存在什么缺陷？Linus没能在现有
的VCS中找到相关的到底特性是什么？让我们来看看。

主动开发
开发目标有很多方面，Linus 希望有一个新的覆盖这些方面的能力。它允许并行开发，
各个人可以在自己的版本库中同时开发，而不需要与一个库中的独立版本同时地时刻同步（因为这样会造成
开发工作）。它必须允许许多人员在不同的地方，是离线的情况下，可以方便地开发，甚至

胜任上千开发人员的规模
新的开发人员都知道，Linux都需要开发人员的最新开发能力，这是
新的开发人员能够支持的。工作在整个项目也还是一样
的部分。当然的VCS能够坚持新的这些不同的工作整合起来。

性能优异
Linus 决心确保新的 VCS 能够快速且高效地执行。为了支持 Linux 内核开发中的更新操作，他
知道无论是个人操作，还是大量的存储传输传输操作，都需要保证执行速度。 ，扩展
传输时间，需要“使用”和“比较技术”。确保使用不同
的网络展示模式来开发，不仅影响了日常开发，而且还提供了同样的显示效果。 。

保持正确和正确
因为
Git人员需要从另一个版本和另一个开发者那里发现，在从另一个版本开发到如何开发到的版本。 Git使用一个通用的“没有数据安全到散列函数”（SHA1）的加密到散列函数的通用
方法？
，来查找和查明中的对象，
虽然可能认为不是绝对的，但是在实践中，已经是可靠的手段。

强化责任
Git 将控制发布文件的关键方面，就包括使用谁的原因来应对每个有系统的历史
文件的提交（Git 的一个版本最多可以使用一个版本的“提交”）强制执行了 Git 对每个有系统文件的提交。 “日志”中存储的信息

由开发人员、项目需求、管理策略决定。Git确保被VCS管理的文件不会名地修改，因为它可以
对所有的作品进行莫名追踪。

不可变

Git中存储的数据对象当然只是不能修改的数据库。数据对象的数据并不会
替换整个历史对象的设计同时意味着存储也不会在不公开的情况下不
改变对象的数据库，并且具有相同的数据库性质，并且可以快速使用。

原子事务
原子事务，可以让不同但的操作或全部执行或有一个相关的执行。
在进行更新数据库的提交时，不会通过状态库或操作这些状态来记录完整、离散的
版本。 。

支持并鼓励基础的开发
几乎所有的VCS都在同一个存在多个“支线”。例如，支持变更代码的一条支线中立的项目“开发”，
而每条VCS同样可以将另一条支线分叉为多条支线，以后在再将另一条支线进行“测试”。
就像大多数VC的分支线一样，Git这样的简单支线“分支线”，每个分支都命名。并且
用不同的分支来合并分支线。
因为通常来说，简单的分支合并是各个 VCS 使用中最困难和方便的操作，所以，
能够简单、清晰、快速地提供一个功能，是非常需要的。

完整的版本库
以便开发者提供一个人的版本库中关于
文件的完整历史修订信息非常重要。
清晰的内部设计
即使最终用户可能不一定有开发者的内部设计，对于Linus以及其他简单的Git来说，确实
非常重要。Git的模型拥有的结构，并且能够保存原始数据模型的部分和
将对象模型和最新的技术结合起来，可以方便地提供一个方便
的环境数据对象。

免费自由（自由，如在自由中）
——纳夫曾说过。

创造一个新的VCS有清晰的理由后，众多软件工程师共同创作Git。需求是创新之母！

1.3 先例
VCS 的完整历史超出了本书的讨论范围。然而，有一些具有里程碑意义、创新意义的系统值得一提。
系统对Git的开发或者有重要的铺垫意义，或者有引导意义。（本节为任选章节，希望能够记录那些新
特性出现的时间，以及在自由软件社区流行的时间。）
源代码几个控制系统（Source Code Control System, SCCS）是UNIX^2上最初的系统之一，由MJ
Rochkind于20世纪70年代早期开发。[“The Source Code Control System,” IEEE Transactions on
Software Engineering 1( 4) (1975): 364-370.]这是有证可在 UNIX 系统上运行的基本版本的 VCS
。沿用至今
。SCCS了一个模型来保证过程简单的
运行顺序。 ，他则需要锁定并检测出通过UNIX文件系统执行的
转换）。待完成以后，他又可以将文件检测版本库中并编辑并入
（修订控制系统）由Walter F. Tichy 于 20 世纪 80 年代早期引入 [“RCS: A
System for Version Control,” Software Practice and Experience 15(7) (1985): 637-654.]。RCS 引入了差值
不同的概念，来提高文件不同的存储效率。最初的
并行系统（Concurrent Version System，CVS）Dick Grune 于 1986 年并实现。 4 之后又由
Berliner 和他的版本模型重新实现，实现此次 CVS 版本VS 开发流行，并且成为
（http:www.source 各区各区的实际情况）。C 具有优势实施范围，非常适合在RC 的
范围内和标准。整个“模块”的更改集范式。
另外，CVS 只引入了一个关于“锁定”人员的新系统而需要开发人员在修改之前的某个文件之前先锁定，
同时一个开发人员进行了修改，它所有需要修改这个文件的开发人员都需要随时开发人员
。CVS每个人提供自己的开发人员可以自行
开发的不同的私有权限。如果出现修改相同的行情，那这一行将作为“突破”被标注出来，由开发
人员手动解决。这个锁锁规则有多种“开发人员可以共同编写”
。发生的那样，对 CVS 短处和改进的改进，是新的 VCS 的诞生：Subversion（SVN）。SVN 于
2001 年问世，以迅速风靡了社区促进。CVS，SVN 原子方式提交释放部分，并且更好的
Mercurial Keeper 则抛弃了上面所有的解决方案。获得了它的概念，取而代之的，
数据是具有时代意义的，每个开发人员自己都可以共享的。库副本从端点对。
以 Peer 的模型继承而来。
，Mercurial 和 Monot 用散列的唯一标识来首创唯一标识的内容，而唯一标识的内容，只是一个“外号”，后来用文件名
方便用户操作，再没有其他作用了。Git 沿用从内部上来说，Git 的这个文件是基于这个文件实现的。

(^2) UNIX是Open Group在美国和其他国家的注册商标。——原注

的内容，命名为“内容可寻址文件存储”（Content Addressable File Store，CAFS）的概念。这
不是一个新概念。见“The Venti Filesystem”（Plan 9），贝尔实验室，
[http ://www.usenix.org/events/fast02/quinlan/quinlan_html/index.] 根据 Linus 的这个直接^3，Git 从
Monotone 借用了这个概念。Mercurial 也同时实现了这个概念。

1.4 时间线
应用的场景，有更多的需求，再上对即将推出的5天新股动力，VC于2017年7月50日50月5日自投产。
4月15日，Git从以下启动，1月5日成为额外的项目
。commit e8366366f89bfbde79923ca23ca22604
作者：Linus Torvalds torvalds@ppc970.osdl.org
日期：Thu Apr 7 15:13:13 2005 –
来自地狱的信息管理器“git”的初始修订

不久之后，Linux 内核的第一次提交也诞生了。
commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac
作者：Linus Torvalds torvalds@ppc970.osdl.org
日期：Sat Apr 16 15:20:36 2005 –
Linux-2.6.12-rc
Initial git repository build . 我不在乎完整的历史，
即使我们有它。
如果我们愿意，我们可以稍后创建一个单独的“历史” git存档，同时
导入 git 时它大约为 3.2GB -
当我们没有很多好的
基础设施。
让它撕裂！

本次提交将整个Linux内核信息导入Git版本库中^4。本次提交的统计如下：
17291个文件更改，6718755个插入（+），0个删除（-）

是的，这次提交
了 0000000000000000 50 足足用了 7 年的时间，Linux 内核第一次用了 3 个小时。Linus 在 20 年 4 月 20 日向内核邮件
列表，正式开始上Git了！

(^3) 私人电子邮件。——原
(^4)关于旧的Bitkeeper日志如何导入Git版本库（2.5）的悠久历史之前的起点，见http://kerneltrap. org/node/13996。——
原注

在 20 年 7 月 25 日，Linus 将 Git 代码维护
工作
大概。 ，版本号为2.6.12的Linux内核正式发布，所用VCS Git。

1.5 名称要求
根据Linus，我现在的所有项目都是自己的名字，命名为Git，因为“我是自己的混血儿，我自己命名，是Linuxgit
”^5。如果，Linux是Linus和Minix的先人那么反之，用一个更无用语言表达
的措辞也不是可能。 那
之后，也有人曾建议，一个使用一些人类协商的解释。
器（全球信息追踪器）。

(^5) 见http://www.infoworld.com/article/05/04/19/HNtorvaldswork_1.html。——原注

第 4 章 基本的 Git 概念
4.1 基本概念
它之前的一章介绍了一个典型应用，并且可能发现它是什么整个文件？为什么我有很多的问题。Git 是否在每个提交时存储的文件中？
git 应该是什么？如果你
用过其他的 VC，比如
SVN复杂。一些基本的和不同的方面，Git会有所不同。

演讲库的关键会通过几个重要的概念来讨论G的组成讨论和讨论。这里有一个版本2和1个
基础演示如何与多个知识库联系会的第1个版本讨论会。追踪多个版本库可能看起来
是艰巨的任务，你在学习的基本原则是同样适用的。

4.1.1 版本库
Git 版本库（使用存储库）只是一个数据库，其中所有的控制和管理都简单方便地维护和管理项目的版本和
信息。在 Git 中，与包含大多数版本系统，一个版本库维护项目整个生命周期的不同的是
，
Git 在副本库中提供了所有副本的完整版本库中的所有版本，还提供了副本库中的所有版本库配置的值。前面的你已经看到了其中的一些，例如，库的用户名和 电子邮件
地址。
相反，Git 对每个网站、每个用户和每个版本库的设置和信息都
进行与管理和检查。
在版本库中，Git 维护两个主要的数据结构：对象库（object）和索引（index）。所有这些版本
库保存在工作数据子目录下一个名为.git的有效目录中。
对象库在复制操作的时候能够进行复制，这类似的索引是为了更好地支持市场上的风险投资公司的一种专有技术，并且是一种专有的技术，并且是需要的。 接下来的两季
信息可以在和交易的时候进行。
和索引进行更详细的描述。

4.1.2 Git对象类型
对象库是 Git 库的实现消息的核心。它包含你的数据文件和实现的消息、作者信息、日期，以及其他使用错误库中的所有 项目
版本或分支的信息。
种类类型：块（blob）、目录树（tree）、提交（commit）和标签（tag）。
这4种原子对象构成了Git高层数据结构的基础。

块（斑点）
文件的每一个为一个块b）
。blob的常用术语，指代某些版本可以为一个领域的变量使用或或同时内部结构会加载。
一个blob被一个程序黑盒保存。一个blob保存一个文件的数据，但不包含任何关于这个文件的元数据，甚至
连其文件名也没有。

目录树（树）
一个代表目录树的目录信息（目录树）、目录文件中的目录名信息。
它也可以在目录中包含一些其他项目或目录树，并创建一个目录树。和子目录的完整层次结构。

提交（提交）
一个提交（提交）对象版本库中每一次更改的数据，包括提交者、提交者、提交日期和日志
的目录。是父亲提交时库的状态。最初的提交或根提交（ root
commit）
提交父。

标签（tag）
一个标签对象分配一个任意的人类，这通常可以命名给一个特定对象，是一个提交对象。
但是，一个更复杂的标签
名称（如 Ver-15）57ca 会
随着时间的推移而变化！为有效利用地盘空间和网络
项目的编辑、添加和删除被追踪和
模型。

4.1.3 索引
索引是临时、动态的库文件，是一个完整版本的目录。
可以每一个时刻的整体结构的一个版本。项目的状态可以用一个提交和一个集合目录树表示，它来自项目历史历史
中的任意时刻，或者它可以是你正在开发的未来状态。
Git 的关键特性之一允许你使用、定义好的步骤来改变索引的内容。索引有条理它之间的开发它的行为与
提交的变更分离开来。
下面是它的工作原理。开发Git 会在索引中保存（stage）变更。通常是添加、删除或删除命令
临时编辑文件或执行那些文件。
还可以替换索引中变更因此，索引支持一个由你删除到或从你的复杂版本库状态的版本库状态一个可以推测的更好的
状态的逐步过渡的章节。
在第 9 中，索引查看查看在合并（合并）中，允许同时管理一个文件的多个版本、检查和同时操作

的重要作用。
4.1.4 可寻址内容名称

Git对象库被及成一个内容寻址的存储系统。因为一个对象的内容决定了这个
散列值，并且认为这个散列值能够有效地满足特定的内容，所以SHA1散列值完全满足了做数据库中
对象的名字和索引SHA1 被散列的数值
是
一个 160 位的十六位数字，通常是一个 40 位的数字，举例来说
，用户表示的数字是一个数字，显示的数字是一个数字
和一个数字。

本体唯一性

不管在哪里计算，SHA 是散布不管它在哪里计算的一个重要特性，始终在同样的重要
目录中产生相同的 ID 内容。在机器中的不同列里甚至不同的内容中产生相同的内容。文件的 SHA1 的不同列
ID 是不同的有效值。

这里有一个巨大的推论，在互联网上，文件或各种 blob 都只是可以通过一个大小
来判断它们是否相同。

4.1.5 Git追踪内容
理解Git的一个特殊操作还是一个，VC是很重要的同时内容跟踪系统（内容跟踪系统）。
这种很细微，指导了Git的，而且这很可能是内部处理主要的关键原因 是
什么内容
大多数其他^1修改控制系统一样。
首先，Git 的对象库基于对象的散列计算的值是基于目录的用户原始文件布局，而不是文件名或名
设置。因此，当 Git 放置文件对象库中的时间它基于目录的数据而不是文件名，而不是文件名，而不是文件名，
Git并没有追踪到这些文件名次相关的文件名。再次内容显示，Git 追踪的是文件名如果两个文件
的内容完全一样，不管是否在目录中，Git 在对象库里只保存一个 blob 形式的内容副本。Git 只是
根据文件内容来计算每个文件的列码，如果文件有相同内容的 SHA，它们的相同，然后将这个 blob 用户的一个结构
对象库作为，并以 SHA11
目录为标准。 ，都使用这些相同的 对象
指代其内容。
加到对象库里。原来的blob在对象库里保持不变，为没有变化的文件所

（^1 Monotone、ercur、OpenCMS 和 Venti 是一些少数的例外。—原注

使用。
当文件从一个版本的内部变化到下一个版本的时候，Git 存储文件的数据库有效地作为每个版本，而
不是它们的差异。因为 Git 使用一个文件的所有内容的内部散列值。名，所以它必须对每个文件的完整
副本进行操作。Git 不能将工作或者对象库所在的副本创建在文件内容的或者文件的两个版本之间的区别
上。
文件拥有修订和从一个版本到副本 Git
用不同的散列值的 blob 之间的区别来计算历史，而不是直接存储一个文件名和个性差异。
算，但这个特性让 Git 在执行某个任务的时候非常容易。

4.1.6 路径名与内容
和很多其他 VCS 一样，Git 维护明确的文件列表来组成版本库的。然而，这个需要并不
需要Git 的基础文件名。实际上，Git 需要把文件名有几个不同的文件内容这样，Git 从
传统数据库的索引中分离出来了。看看表 4-1 会很有帮助，它粗略地比较了 Git 和其他类似的系统。

表4-1 数据库对比
系 统 索 引 机 制 数 据 存 储
传统数据库 索引顺序存取
方法（ISAM）
数据记录
UNIX文件系统 目录
（ /path/to/file ）
数据块
Git .git/objects/hash
、树对象内容
Git 记录的路径名，并且能够确保
目标 文件的内容和目录，这些都是来自散布它的内容列值来索引 。Git 的物理数据排列并不完整。用户的文件结构不同。相反，它有一个不同的结构，却可以操作存储目录的原始结构。在考虑其自身内部和和方面，Git 当 Git 创建一个工作的时候，它对文件系统的目录：“说嘿需要！我有这样大的一个 blob 数据，应该有 路径注明path/to /directory/file。你能吗？”文件系统回复说：“啊，是啊，我认出那个字符串是 我知道你的这些子目录名，并且把那个地方的blob数据放在哪里！谢谢！ ！”







4.1.7 打包文件
每个聪明的读者可能已经有了关于 Git 的数据模型和单独文件文件的不去的问题：直接存储每个
文件版本的完整内容是否太低效率了？即使它是压缩的，如果你只添加一行到不是文件里， Git
是不是要存储两个版本的内容？
幸运的是，答案是“不是，不完整”是！
Git使用了一种不同的排序机制，比较有效的分类存储文件（打包文件）。要创建打包文件，Git首先是所有
内容非常相似的文件，然后为它们之后的内容之一。例如，如果你只是更改或添加文件中的行，
Git可能会存储新版本的全部内容，然后记录
那行更改作为差异，并在包中。
存储一个文件的整个版本，并使用另一个不同的不同文件的不同
。 。

然而，Git 文件打包得说得非常巧妙。因为 Git 是由内容驱动的，所以它之间并不真正适合计算出来的文件
的区别是否属于同一个文件的两个版本。这就是，Git 可以在库中的任何地方，只要有两个
良好的计算差异，它认为文件可能会类似来的数据显示。因此，Git 有相当多的复杂的算法来
匹配版本和匹配版本。此外
，Git还可以
维护打包文件中的每个完整文件（包括完整内容的文件和通过差异重建出来的文件）的文件）的
SHA1 值。这给定位包内对象的索引机制提供了基础。
打包文件与对象库中的其他对象存储。它们也用于网络中版本库的原始数据传输。

4.2 对象库图示

blob对象完整是数据结构的“端”；它也不是而且还被对象。在下面的图里，引用每个对象blob 由
一个表示。
任何对象指向某个对象。也可能指向其他对象。不同的树对象可能
由一个表示
。一个对象指向一个特定的每个对象，并且这个树对象是由提交对象引入
库的。每个对象
由一个平行四边形表示。可以指向
一个基本提交对象。分支不是一个树的 Git 对象，它展示了一个展示
对象的时候，她在展示了两个角色。把每个分支画成圆形的角方形。
图 4-1 展示了所有库在协作图显示了一个版本。但是一个文件的最初在提交对象后的状态。
同时他们的文件的主分支和一个叫V1.0的标签都指向ID为1492的提交对象。

图4-1 Git对象
现在，让事情变得有点复杂。保留原来我们的两个文件不变，添加一个包含一个目录。
对象库就如图4-2所示。

图 4-2 二次状态提交后的 Git 对象像前一张图里，新提交的对象添加了一个关联的对象来表示和文件结构的总和
。在这里，它是
ID 为 cafed00d 的对象
因为顶级对象的内容也被添加了的新子目录改变了，树顶级对象的内容也跟着改变了，所以Git引用了一个新的树
对象：cafed00d 。
然而，blob对象dead23和feeb1e在从第一次到第第二次提交的时候没有发生变化。Git意识到树没有变化，
所以可以被新的cafed00d树对象直接引用和共享。
请注意提交对象中间箭头的方向。父提交在上来得更早的时间。因此，在 Git 的状态下，每个提交对象
的表态都反映了它的一个或多个父提交的实现。很多人这个数据画面通常指望着方向，因为版本库的版本形成反：流从父提交
流向
子提交。 6章扩展了这些图来展示版本库的历史是如何建立和被不同命令操作的。

4.3 Git 在工作时的概念
一些原则，来看看所有这些概念和成分是如何在版本库里结合的。让我们创造一个新的版本。
库，并更详细地检查内部文件和对象库。
4.3.1 进入.git目录
首先，使用 git init 来初始化一个空的版本库，然后运行查找来都创建构建文件。
$ mkdir /tmp/hello
$ cd /tmp/hello
$ git init
在 /tmp/hello/ 中初始化空的 Git 存储库.git/

当前目录中的所有文件
$ 查找。
.
./.git
./.git/hooks
./.git/hooks/commit-msg.sample
./.git/hooks/applypatch-msg.sample
./.git/hooks/pre-applypatch.sample
./.git /hooks/post-commit.sample
./.git/hooks/pre-rebase.sample
./.git/hooks/post-receive.sample
./.git/hooks/prepare-commit-msg.sample
./.git /hooks/post-update.sample
./.git/hooks/pre-commit.sample
./.git/hooks/update.sample
./.git/refs
./.git/refs/heads
./.git/refs /tags
./.git/config
./.git/objects
./.git/objects/pack
./.git/objects/info
./.git/description
./.git/HEAD
./.git/branches

./.git/info
./.git/info/exclude

可以看到内容，.git 包含很多内容。这些文件是基于模板目录的，根据需要可以进行调整。根据使用
的 Git 目录的版本，实际列表可能会有一点不同。例如，旧版本的 Git 不正确.git/hooks文件使用。

在一般情况下，不需要查看或隐藏 git 下的文件目录。这些“这些”的文件是 Git
（管道）或。Git 隐藏有部分操作的操作命令来处理部分文件 。，但你很少会占用
它们的位置。
最初，除了使用的.gitgit / objects .git/objects 目录/所有目录是空的。对象 .git/objects/pack .git/objects/info




现在，让我们来小心地创造一个简单的对象。
$ echo "hello world" > hello.txt
$ git add hello.txt

如果输入的“hello world 跟这里一样”（没有改变objects目录和大小写），那么应该如下所示：
$ find .git/objects
.git/objects
.git/objects/pack
.git/objects/3b
。 git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad
.git/objects/info

这一切看起来都很神秘。简单来说，下面各节会慢慢解释原因。

4.3.2 对象、散列和blob
当为hello.t__xt创建一个对象的时候，Git 并不关心 hello.txt的文件名。Git 只关心文件里面的内容：表示
“hello world”的 12 个字节和换行符（跟一个之前创建的 blob 一样）把它作为对这个名字的一些操作，计算
出它的SHA1散列值的表达方式，表示把它的名字分配给这个随便一个库中。

如何知道一个SHA1散列值是唯一的？

一个相同的 SHA1 散列值的机会十分渺茫。当这种情况发生的时候，称为碰撞。然而，
一次 SHA1 发生的不同类型太低，你可以放心地认为它不会干扰我们对Git 的使用。

SHA1是“安全散列加密”算法。直到现在，没有任何已知的方法（除了运气之外）可以让一个用户刻意
造成一次碰撞。碰撞会发生吗？我们随时来看看。

对于 160 曝光，你有 2160 或者大约 1048 （1 个后面的 48 个 0 ）种可能有一个散列值。这个数字是巨大的。
你就业一万亿年的唯一一个潜在的目标是一万亿个Blob对象，持续一万亿年，你只有1043个blob对象。

如果你散列了 280 一个词条，可能会发生碰撞。

不相信我们的话，就去读Bruce Schneier的书吧^2。
在这种情况下散列值为3b18e512dba79e4c8300dd08aeb37f8e728b8dad。160位的SHA1散列值20个
字节，需要40个字节的十六个字节其他内容来显示，因此这个存为。
git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad。Git在前面的数字后面插入一个“/”提高
文件系统效率（如果你的文件以同一个中，一些系统会变慢；使 SHA1的第一个字节
成为一个很容易的办法，可以为所有简单分发的可能对象创建一个固定的、 256路目录分区的命名
空间）。
很多事情（它还是同样的内容“hello world”），可以在任何时间
使用散列值把它从对象库里抽取出来。
$ git cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad
hello world

提示
Git手动输入40个字符是很不切实际的，因此它通过对象
的唯一值提供
了一个查看对象的
散列。

4.3.3 文件和树
“你好世界”那个blob已经在对象库里了，那么如果它的文件名又发生了 呢
？
一种来命名目录树（tree）的对象并来跟踪文件的路径名。当添加 git 添加命令时，
Git 会给每个人的创建一个对象，但它的内容不会马上为创建一个对象。相反，索引更新了
。git /index中，它跟踪文件的路径名和索引相应的blob。每次执行命令（git add、git rm 或
git mv）的时候，Git 会用新的路径名和blob信息来更新索引。

(^2) 《应用密码学》的作者、美国密码学学者、信息安全专家与作家。——译者注

任何时候，只要从当前索引创建对象，只要通过索引来编写一个命令都可以索引当前树。信息的索引
就可以了，
目前，只包含一个文件，你好。
$ git ls-files -s
100644 3b18e512dba79e4c8300dd08aeb37f8e728b8dad 0 hello.txt

在这里 查看文件的关联，hello.txt 与3b18e4
。对象 .git/objects .git/objects/68 .git/objects/68/aba62e560c0ebc3396e8ae9335232cd93a3f60 .git/objects/pack .git/objects/3b .git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad .git/objects/info










现在有：18e5的对象和一个新的68aba6树子，
SHA1 目录对象名完全。
因为它是一个对象，就像 blob 一样，所以可以用动物命令来查看它。
$ git cat-file -p68aba6
100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad hello.txt

第一个数字100644，是对象的文件命令的八句话，用过UNIX的
chmod的人应该对这个很现实了。这里，3b18e5是hello world的blob的对象名，hello.txt是该球
的名字。
当执行 git ls 的时候，很容易就可以看到 - 文件与树人已经有关联中的信息。

4.3.4 对Git使用SHA1的一点说明
在更详细地讲解树对象的内容之前，让我们先来看看SHA1散列的一个重要特性。
$ git write-tree
68aba62e560c0ebc3396e8ae9335232cd93a3f60
$ git write-tree
68aba62e560c0ebc3396e8ae9335232cd93a3f60
$ git write-tree
68aba62e560c0ebc3396e8ae9335232cd93a3f60

每次对相同的索引计算一个树对象，它们的SHA1列值仍是完全一样的。Git不需要重新创建一个新
的树对象。如果你在计算机前按照这些步骤操作，你应该看到完全一样的的SHA1散列值，跟书刊一样

的一样。
看起来，这个散列类输入在这样可能会产生一个真正的函数：给定的，它总相同的输出。
当然，任何散列函数（即使是低的）
级的奇偶校验位）也有这个属性。
不管怎样，如果你和其他开发人员创建了相同的内容，你们俩在什么时候工作，都一样的

但是等是所有类型的人，无论是哪一类人，都不会产生这样的结果。会产生 一次碰撞
吗
？
SHA1 散列值并不算
碰撞。
Git SHA1 SHA1 列函数的后遗症：你是如何得到被称为 68aba62e560c0ebc3396 e8ae9335232cd93a3f60
的树的不是。另一个
树对象是一样的。 Bob 通过 Jennie 的 A、B 和 Sergey 的提交 C 来创建这个树，而读者你
是从 Sue 提交 A，然后从 Lakshmi 那里更新提交 B 和 C
68aba6e560c0ebc3333360
，你能找到一个加密列的对象，这样你就可以找到
一个6889a9a360 ，因为你可以找到一个加密列的对象。那个对象同样可以创建这样的数据：如果你在你
的
对象库里找到了某个散列值的对象，你就跟在你身边没有拥有的人
那个对象的副本。总之，你可以判断你的对象库是否有某个特定的对象，即使你对它（可能非常大）
的内容一无所有。因此，散列就好似对象的可靠标签或名称。
_
所有树和blob的散列，因此可以归结为它唯一
通过原始提交的散列值标识整个数据结构在提交时的状态。
最后，我们在上一段中的声明可以推出散列函数的强大应用：它提供了一种有效的方法来比较两个对象，
甚至是两个非常大而复杂的数据结构^3，而且不需要完全传输。

4.3.5 树层次结构
它的文件的信息很好的管理着一节一节所讲的项目，只是上面的目录结构，
并且会随着时间的推移 ，让我们看到新的新目录和 构建和 移动。 /你好



(^3) 对这个数据结构更详细的描述见6.3.2节。——原注

$ MKDIR子目录
$ CP hello.txt的子目录/
$ git的添加子目录/ hello.txt的
$混帐写树
492413269336d21fac079d4a4672e55d5d2147ac
$ git的猫文件-p 4924132693
100644一滴3b18e512dba79e4c8300dd08aeb37f8e728b8dad hello.txt的
040000树68aba62e560c0ebc3396e8ae9335232cd93a3f60子目录

新的顶级树包含目录：原始的你好。txt以及新的子目录，子目录不是blob
。68abae5600c ebc3396e8ae935232cd93a3f60 之前 只有一个“你好”的最初的“树”内容。所以， subdir新树树文件跟旧的“hello world”文件是完全一样的！ 让我们来看看.git /objects目录，看看最近的变化有哪些影响。 $ find .git/objects .git/objects .git/objects/49 .git/objects/49 /2413269336d21fac079d4a4672e55d5d2147ac .git/objects/68 .git/objects/68/aba62e560c0ebc3396e8ae9335232cd93a3f60 .git/objects/pack .git/objects/3b












.git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad
.git/objects/info

这只有三个唯一的对象：一个包含“hello world”的blob；一棵树包含hello.txt的树，文件里是“hello
world”加行换；还有第一棵树旁边包含hello.txt的另一个一个索引的另一棵树。

4.3.6 提交
下一个主题是提交（commit）。已经通过git命令添加了，对象也git write-
tree命令生成，可以像树一样通过使用命令那样创建提交对象。
$echo -n "提交一个打招呼的文件\n"
| git 提交树 492413269336d21fac079d4a4672e55d5d2147ac
3ede4622cc241bcb09683af36360e7413b9ddf6c

结果如下所示。
$ git cat-file -p 3ede462
tree 492413269336d21fac079d4a4672e55d5d2147ac
作者 Jon Loeliger jdl@example.com 1220233277 -0500

提交者 Jon Loeliger jdl@example.com 1220233277 -0500
提交一个打招呼的文件

如果你在计算机上发现步骤，你可能会和你生成的提交对象跟书上的不一样
。提交包含你的名字和创建提交，
尽管这很微小，但仍然是不同的：不同的时间，你的提交确实有树的
。的提交通常指向同一棵树。当这种情况发生时，Git 能够巧妙地生活只传输的
提交，是很有可能的树和 blob 对象。
在实际中，你可以（并且应该）跳过的 git write-tree 和 git commit-tree，并只使用 git
commit 命令。成为一个完全快乐的 Git，你不需要
提交那些生命命令。对象是相当简单的，这是一个真正的RCS需要的最终组成部分。提交对象可能是最
简单的一个，包含：
● 标识关联文件的树对象的名称；
● 创作新的人（作者）的名字和创作的修改时间；
● 把新消息版本库的人（作者名字和提交的时间）；
● 对本次的说明（提交）。
默认情况下提交，作者和提交者是同一个个人，也有一些情况下，他们是不同的。

提示
可以使用 git show --pretty=fuller 命令来查看给定提交的其他细节。
尽管提交对象与树对象的结构完全不同，但它也存储在图结构中。当你做一个新的提交时，你
可以给它一个或多个父提交。通过继承链来回溯，可以查看项目历史。第6章会提出关于提交和提交图的
更详细描述。

4.3.7 标签
最后，Git 还管理的一个对象标签。尽管 Git 只实现了一种标签对象，但通常有轻量级的基本标签类型，
称为量级的（轻量级）和带附注的（带注释的）。
轻量级只是一个提交对象的版本库，通常被建立在版本库里而不是创建对象的版本库
。
Git
在命名一个提交的时候对轻量级的消息和级别的消息标签，但是，默认情况下，很多 Git 的命令的级别的消息可以对标签进行
标记。的标签，因为被认为是“永久”的对象。
可以通过git tag命令来一个签名信息提交、附注且未创建的标签：
$ git tag -m "Tag version 1.0" V1.0 3ede462

可以通过 git cat-file -p 来查看标签对象，标签对象的 SHA1 值是命令
提示吗？但是为了它，使用 4.2 节的命令。

$ git rev-parse v1.0
6b608c109394348117dd18b1ba11117dd18b1ba11c6a
$ git cat-file -p 6b608c
对象3de4622cc241bcb09683b9ddf6c
type commit
tag v1.0
tagger jon loeliger jdl@example.com sun 10月26日17:07:15 2008 -0500
标签版本1.0

除了消息和 VCS 之外，标签指向提交对象 3e462。通常，Git 会通过信息日志给作者的其他情况下给特定的
提交标签。请注意，这种行为有明显的不同
。Git 通常对象的提交对象打标签，这个树对象包含中文件和目录的整个层次结构库的总状态。

回想一下图
4-1492-10
适用的树的所有文件。一个单独的移动文件应用标签，然后所有依赖打过标签的文件来重建一个完整的
标记。并且CVS允许你移动到你个人移动文件的标签，而Git则需要在单独的移动文件的地方做一个新的提交，括
该文件的状态变化。

第 21 章 Git 和 GitHub
虽然本书前面的章节主要关注于Git的命令行工具，但是自从 2005 年开始，Git支持和促进了一些关于它
的社区和工具的发展。这些工具有数百个，并且有很多不同的形式，类型从桌面GUI（如SmartGit，
http://syneveo.com/smartgit）到桌面备份工具（如SparkleShare，http://sparkshare.org）。但是在这些工具
之外，有一个在开发人员甚至非开发人员中心中都占有最显著的地位，它就是GitHub。
图21-1所示就是这个网站的首页，网站所介绍的概念——社会化编程，很可能在前几年被忽略掉，但是
现在确是我们中的许多人认为应该有的工作方式。社会化编程的这种模式首先用在开源项目中，但是在
最近两年，在地理上的分布式协作开发已经在闭源的企业中有所发展。下来就让我们看看GitHub为我们
提供什么。

图21-1 GitHub主页
21.1 为开源代码提供版本库
有统计数据系显示，很多开发人员和Git第一次的接触就是从GitHub上克隆版本库。这正是GitHub的原
始功能。它提供了一个能够通过git://：、https://和git+ssh://这些协议与版本库交互的界面。对于开源项
目，账户是免费的，并且所有账户可以创建不限数量的公共版本库。这极大地促进了语言的开源社区
（从JavaScript到ClojureScript）对Git的使用。
在浏览器中打开网址http://github.com，然后单击图21-2中的Sign Up链接就能开始创建新账户。

图21-2 选择账户类型
GitHub有 4 种账户类型：免费个人账户、付费个人账户、免费组织账户和付费组织账户。要加入一个组
织必须要有个人账户。在选择用户名的时候需要慎重一点，因为默认一个账户只有一次修改用户名的机
会（见图21-3）。一个账户可以关联多个邮箱地址，并且可以随时更改。因此，用户名是最永久性的注
册信息。
注册完最常见的账户类型——免费个人账户之后（见图21-4），用户会被引导到GitHub的帮助页面，这
里会提供一些教程，这些教程介绍设置开发人员桌面安装的Git的参数配置。

图21-3 免费个人账户
图21-4 账户创建完成
21.2 创建GitHub 的版本库
新版本库信息
在你创建账户之后，只需要单击最顶部的New Repository按钮就可以创建新版本库，这个按钮在你每次
登录后的界面上都会显示。也可以通过输入http://github.com/new来创建新的版本库。
唯一必需的信息是版本库的名字。另外也可以设置项目的描述信息和项目首页的URL来使项目更加容易
识别（见图21-5）。

图21-5 创建公开版本库
接下来，需要设置一些版本库的初始信息。根据你现在是否已经有提交，这里有两种途径。

README Seeding（选项一）
如果项目的第一步工作是在开始编写代码前创建GitHub版本库，那么你将需要创建一个占位符文件作为
第一次提交。在创建新版本库的时候，你会被问及是否创建初始的 README 文件和 .gitignore 文件。
README 文本文件一般用来描述项目的意图。
至此，项目可以利用命令git clone url 克隆到本地，之后，就可以在本地添加和提交代码了。

添加远程版本库（选项二）
如果你已经拥有了一个本地版本库，你可以将GitHub的地址和已经存在的本地版本库链接起来。要做到
这一点，需要利用命令git remote add url 将GitHub的URL（Git的一个远程地址）添加到已经存在的
Git版本库中。

将本地的内容推送到GitHub
在经过上面的步骤之后，本地版本库已经链接到远程版本库。本地版本库的内容可以推送到GitHub。这
需要利用命令git push remote branch 。如果分支之前从未发布，明确的命令git push -u origin master比较合
适。-u告诉Git去跟踪推送的分支，将它推送到origin远程版本库，同时将它推送到master分支。
一旦将GitHub的版本库和之前的版本库建立联系，之后进行的代码改变就可以简单地通过调用git
push来推送。这便产生了使用可访问的中心Git版本库的好处，进行分布式协作的开发人员可以看见其
他所有项目参与者提交的更改（见图21-6），即使他们是离线的。

图21-6 GitHub上的提交历史记录
21.3 开源代码的社会化编程
GitHub可以局限地被看做一个托管开源项目的地方。然而，在线创建版本库的概念其实已经被
SourceForge和Google Code很好的利用，它们都有各自有优势的用户界面。其他一些关于组织条款、证
书和提交权利的概念由Apache基金会、Codehaus和Eclipse基金会进行了深化。
但是GitHub创造了完全不同的方式去促进协作，这便是利用社区贡献（见图21-7）。GitHub提供类似
Twitter、Facebook等其他一些社交网站一样的社会化方面来记录编程中的社会化活动。Watch使得用户
可以关注感兴趣的项目，版本库Fork允许用户复刻项目，Pull Requests可以使其他程序员向原项目的拥
有者发送合并请求，行级 Comments使得用户可以对提交进行具体的留言和评价，综合上面的功能来看，
GitHub确实将编码变成了一项社会化活动。正是因为这些流程，使得大量开源项目比之前用补丁文件报
bug的时代有了更多的代码贡献者。

图21-7 社会化编程
21.4 关注者
在GitHub上最简单的社会化编程功能就是“关注”，这个操作就是图21-8中的Watch按钮。关注和
Twitter上的跟随者和Facebook上的朋友类似，它意味着你对某个GitHub用户、组织或者特定项目感兴
趣。

图21-8 Watch按钮
关注者的人数也是开源项目受欢迎程度的标志。在GitHub的探索页面里面，对项目的搜索就可以是基于
版本库跟随者数量的（见图21-9）。当这些和编程语言结合起来时，关注者数量可以显示出在某一领域
内有用的样例代码。

图21-9 探索并搜索关注者数量
21.5 新闻源
在你关注了用户、组织或者版本库之后，在图21-10的News Feed中会根据你关注的对象显示内容。这些
新闻源就是你关注的用户版本库或者组织的活动信息。

图21-10 新闻源
新闻源既可以在GitHub.com的网站上查看，也可以作为RSS源由你选择的阅读器应用订阅。

21.6 复刻
复刻其他人的项目是GitHub普及的另外一个概念，这个概念甚至传播到了其他领域（见图21-11）。复
制这个词通常带有负面的内涵。在不久之前，从编码角度来看，复制意味着通过比较鲁莽的方式将程序
引入完全不同方向的复制操作。

图21-11 Fork按钮
GitHub的复刻思想是一个积极的操作。它使得大量贡献者可以用可控制的、可见的方式对项目做出大量
的代码贡献。复刻是一个自发的动作，它使得任何贡献者可以获得项目代码的一个私人副本。这个私人
副本（用GitHub的名词来说就是fork）可以不经原作者的任何明确授权进行更改。这不会对核心项目造
成任何危险，因为这些更改是发生在复刻的版本库中的，而不是原始版本库中。
这和Apache或者Eclipse项目的概念是相反的，它们的补丁被当做bug报告的文件附件提交。GitHub的
这种模式使得社区的贡献是透明和公共可见的（见图21-12），即使在它们提交回核心项目去讨论和合并
前也是这样的。
图21-12的网络图显示了核心项目的分支与提交和非主项目的分支与提交，包括复刻的版本库。这提供了
社区关于这个项目所有活动的概览，还有某个复刻的项目是否明显偏离了核心项目。这使得即使没有发
送合并请求，仍然能够提供很多有意义的分散的社区贡献的概览。

图21-12 网络图
经过数年对社区行为的观察，项目越来越多的边缘用户开始提交修复和小的改善代码，这是因为这样的
事在Github上已经非常方便。很多开源项目已经同时使用原来的bug附带补丁模式以及新的复刻和合并
请求方式。在老的模式下对项目做出贡献的最大障碍在于，准备补丁需要的时间和真正修复bug所花时
间的悬殊。

21.7 创建合并请求
复刻只是对一个项目创建一个私人副本，真正为核心项目带来价值的是合并请求（pull request）。合并请
求是在任何用户进行了他觉得有用的提交操作的情况下，向核心项目拥有者发送的通知。
当一个贡献者完成了一个特性的编码，将它提交到某个命名分支，并且将这个新分支推送到复刻时，它
可以转变成合并请求。合并请求可以精确地描述成“围绕一个主题的提交列表”。合并请求通常都基于
某个主题分支的全部内容。但是，当不是整个分支的内容都准备好推送到一个发布的分支时，合并请求
也可以是一个规模更小的提交。当从下拉的分支选择器中选择了最新推送的分支后，可以单击上下文相
关的Pull Request按钮（见图21-31），这便会出发合并请求。

图21-13 Pull Request按钮
合并请求的默认动作包括在当前主题分支上的所有提交。然而，当调用它的时候，可以手动更改提交的
范围以及源分支和目标分支（见图21-14）。

图21-14 合并请求范围
至此，合并请求已经创建，接下来核心项目的拥有者将会查看、评估、评论，并且有可能合并这些更改。
从概念上来看，这个过程可以拿来和在Crucible和Gerri上进行的代码审查来比较。然而，在GitHub看

来这个流程很好，刚好达到轻量级与能够满足代码审查间的平衡。在GitHub上还可以自动进行融合新代
码的繁重过程，这只需要在Pull Request页面上单击一个按钮。

21.8 管理合并请求
在GitHub上，一个成功的项目会有一系列合并请求需要管理（见图21-15）。核心项目实例的所有协作
者都有管理和处理合并请求的权限。需要注意的是，合并请求可能不是来自复刻的。一些时候，拥有核
心项目协作者权限的开发人员仍然会发送合并请求，这是为了在合并分支时能够获取反馈。

图21-15 项目的合并请求队列
合并请求是GitHub生态圈中十分重要的一部分，以至于每个用户都会有一个属于他自己的自定义面积，
显示的是他作为协作者的所有项目上的合并请求（见图21-16）。

图21-16 全局合并请求队列
在合并请求之后的概念其实是将通常二元的接受或拒绝操作转变成讨论。讨论伴随着关于合并请求的评
论或者关于具体提交的评论（见图21-17）。评论可以是指导性的，意味着已经提交的解决方案还需要进
一步完善。如果贡献者在合并请求的某个分支上又进行了一些提交操作，推送这些提交后，仍然会在合
并请求线程中按顺序显示出来。

图21-17 合并请求评论
评论可以分为三个层次：对合并请求的评论，对提交的评论和对某行代码的评论。其中，行级评论对技
术的改善最有用（见图21-18），它使评论者能够对代码作者提供具有相同逻辑代码的建议。

图21-18 合并请求行级提交评论
当对合并请求的代码做了足够的更改并且已经可以合并到主项目时，可以通过很多方式进行合并。这其
中最创新和节省时间的方式就是通过GitHub用户界面上的自动融合按钮进行融合（见图21-19）。这个
操作会执行真正的Git提交操作，就像从命令行中操作一样。这会省去将代码下载到本地进行融合，然后
再推送回GitHub的过程。

图21-19 合并请求自动融合
发送合并请求会很自然地被看做完成了某个特性的开发、修复了一个bug或者完成其他开发工作。其实，

合并请求也可以在开始一个概念时使用。更常见的是，通过一张JPEG原型图片或者一个概括主题分支目
标的文本文件启动合并请求。这些合并请求通常会征求团队的反馈，而这种反馈就是通过上文所述的合
并请求评论方法实现的。贡献者可以继续向GitHub推送关于那个主题分支的变更，而合并请求会自动地
随着最近的提交而被更新。

21.9 通知
像GitHub这样的社会化系统需要一个强大的通知机制，从而能够通知用户他们关注的项目、组织和用户
发生了哪些改变。如你合理地猜测，通知主要就是上面提到的三种对象产生的对应类型。
所有关于你的通知概览会集中在一个通知页面。这个页面可以通过顶部导航栏的那个消息通知图标进入
（见图21-20）。

图21-20 “通知”按钮
相关通知列表会显示事件源的图标。这些图标包括版本库、用户和组织级的活动。每一条活动的概览还
有事件详细信息的链接（见图21-21）。

图21-21 通知列表
通知可以通过每个版本库页面底部的一个超链接来控制是否开启（见图21-22）。
图21-22 通知版本库开关
对全局通知的修改可以在用户的管理设置页面中进行。哪些类型的事件需要通知，以及是仅仅在网页上
通知，还是也通过用户的邮件地址通知，这些都可以通过这个页面进行设置（见图21-23）。

图21-23 通知设置
21.10 查找用户、项目和代码
GitHub 主要集中了大量的开源项目，同时促进了开源项目的协作，但是，很大一部分开源社区关注寻找
和应用开源库。GitHub 的Explore页面很好地满足了这个需求（见图 21-24）。这个开放的Explore页面

汇聚了一系列版本库，这些从统计数据上显示了趋势，同时能够让开源社区对其产生兴趣。
如果你想查找某种编程语言的示例代码，那么Advanced Search页面就是你想要的（见图21-25）。对用
户、受欢迎度、版本库名和编程语言的设置可以使你进行精准的搜索。

图21-24 探索
图21-25 网站搜索
21.11 维基
在过去更新维基意味着你需要在浏览器上编辑页面。这是一种非常不可靠的并且没有版本控制的方式。
浏览器稍稍刷新就会使更改丢失。
维基是用Markdown（http://www.daringfireball/markdown）语法编辑的Git版本库，并且是依附在相应的
项目上的。GitHub的维基页面（见图21-26）允许提交、评论、融合、变基Git用户可以使用的功能，还
允许执行其他操作，而这些是之前维基用户从来没有使用过的。

图21-26 GitHub维基
通过把版本库克隆到你的本地机器去编辑维基并不意味着放弃了在浏览器中的更改方式（见图21-27）。
在浏览器进行编辑也会写回底层Git版本库，这样用户就可以跟踪作者的活动和所有维基页面更改的历史
记录。

21.12 GitHub页面（用于网站的 Git）
如果维基主页听起来很吸引人，那么使用拥有Git版本库的Markdown文件作为发布整个网站的工具，这
听起来如何？GitHub页面基于Jekyll（https://github.com/mojombo/jekyu），这个项目就提供上述功能，甚
至可以用域名系统（Domain Name System，DNS）CNAME记录映射关联到一个子域名或主域名（见图
21-28）。

图21-27 GitHub在浏览器中编辑维基
图21-28 GitHub页面介绍
Octopress（http://octopress.org，见图21-29）已经从Jekyll和GitHub主页的混合模式中获益，这使得用一
种静态方式发布动态内容变得非常方便。自身安全的缺陷与日益增多的攻击使得使用数据库和即时编译
的动态网站逐渐转为静态页面。但是这不意味着要放弃动态站点的产生，我们只需要将动态处理过程迁
移到产生内容的阶段而不是像使用JSP（JavaServer Page）或者PHP那样在页面请求的阶段。

图21-29 Octopress主页
21.13 页内代码编辑器
通常情况下，用户会在台式机的编辑器中进行编程，但是对于一个微小的更改（比如，修改一个拼写错
误）来说，拉取代码、修改代码、提交代码和推送代码这样的流程太不方便了。出于这样的原因，
GitHub提供了在浏览器中进行代码编辑的功能（见图21-30）。
浏览器内编辑器基于Mozilla的Ace（http://ace.ajax.org/），一个基于JavaScript的控件。这个控件还用于
Cloud9 IDE和Beanstalk。这个控件（见图21-31）支持显示行数、代码突出显示和空格符、制表符格式化。
这样，代码修改变得和在GitHub上浏览源文件一样简单，只需单击Edit，在浏览器内编辑器下面输入提
交消息，然后提交更改即可。微小的修改从来没有这么简单。

图21-30 Ace浏览器内编辑器

图21-31 在浏览器内编辑代码
21.14 对接SVN
虽然GitHub相信Git是VCS的未来，但是可以预计的是SVN仍然会使用很长时间。GitHub支持这两种
版本控制方式。
通常，Git用户将版本库放在SVN中同时使用git-svn命令来对接这两种版本控制技术。然而，这种方法
意味着只有很少的SVN元数据可以保留，而这些数据不包括Git作者、Git提交者信息，以及Git先前提
交的引用。
GitHub让这两种技术对接成为可能，而且不需要客户端会话软件的支持。一个Git版本库可以在请求时
动态转变为SVN版本库，而且这不改变用来克隆的HTTPS URL（见图21-32）。这是一个复杂的动态转
化，而且只有在Github上的Git版本库才能提供。这个技术使得SVN到Git的转变能够以谨慎和渐变的
方式进行。这个在服务器端的对接使Git和SVN的连接不仅能够通过GUI使用，而且能够用其他
SVN遗留连接工具进行提交（见图21-33）。Git的默认分支通常为master分支，这个分支会自动映射到
SVN界面的trunk分支上，这种映射正是提前考虑了在SVN领域中术语的意义。

图21-32 Git版本库的SVN克隆

图21-33 Git-SVN对接
21.15 标签自动归档
当一个开源项目想在GitHub上创建该项目一个压缩的归档时，有一种非常方便的方法：只需要将某个版
本的代码打上标签。Git的标签会自动转变为TGZ和ZIP压缩归档，这些归档可以在标签页找到（见图
21-34）。

图21-34 标签和归档
21.16 组织
至此，本书主要讨论的都是关于相对独立的少量个体GitHub用户的交互操作。然而，Git已经吸引了大
批内聚性很强的组织、小型公司和大型企业。GitHub中的一组功能是为那些“组织”服务的（见图21-
35 ）。

图21-35 组织选择器
GitHub的组织提供了相对个体用户在更高层次上对版本库的拥有权。为了支持这种机制，还有一个附加
的安全结构：团队。团队是一种组织方式，它和一个特定的权限级别和一组版本库相关联。权限的三个
层次是：仅拉取、拉取和推送，以及拉取、推送和管理（见图21-36）。

图21-36 组织权限
21.17 REST风格的API
有一个Web应用确实是个非常好的开始，但是GitHub拥有很多社区开发人员，非常渴望能够使用真正的
服务来构建有用的特性，而不仅仅是是页面。为了促进社区构建支持工具，GitHub建立了全面的应用编
程接口（API）。GitHub的API已经历经了三个阶段，现在API的V3版本提供了API形式的几乎所有
的UI能够提供的特性。在一些情况下，可能在GitHub UI上没有的功能，在API里已经提供了。
下面是一个通过用户获取其所在组织的API（见例21-1）。GitHub API的所有响应都是JSON（JavaScript
Object Natation）格式的。注意，avatar_url实际上是一个完整的长字符串，因为排版原因分为了几行。
例21-1 调用GitHub API
curl https://api.github.com/users/matthewmccullough/orgs
[
{
"avatar_url": "https://secure.gravatar.com/avatar/11f43e3d3b15205be70289ddedfe2de7
?d=https://a248.e.akamai.net/assets.github.com
%2Fimages%2Fgravatars%2Fgravatar-orgs.png",
"login": "gradleware",
"url": "https://api.github.com/orgs/gradleware",
"id": 386945
},
{
"avatar_url": "https://secure.gravatar.com/avatar/61024896f291303615bcd4f7a0dcfb74
?d=https://a248.e.akamai.net/assets.github.com
%2Fimages%2Fgravatars%2Fgravatar-orgs.png",
"login": "github",
"url": "https://api.github.com/orgs/github",
"id": 9919
}
]

GitHub的所有操作都是用RESTful API来组织的，同时在GitHub API站点上有很详细的文档（见图21-
37 ）。除了能够获取用户列表、版本库列表或者文件列表之外，API还提供了开发的标准身份认证接口
OAUTH，来以GitHub用户身份登录。这些使得查询、操作私有版本库的内容，使用版本库作为源代码
之外的产品的存储容器，把构建应用程序从构建版本控制持久化层的困难中抽象出来都成为了可能。

图21-37 GitHub REST API
21.18 闭源的社会化编程
虽然像GitHub这种协作开发模式的来源是开源项目，但是几乎所有的特性都可以在公司内部使用。公司
可以发挥每个员工的才能，即使他们没有赋予某个项目的开发权限。合并请求结合组织和团队内的拉取
使得任何权限的员工都可对项目做出贡献，所需要的只是要有对代码进行审核的核心项目开发人员。

21.19 最终开放源代码
虽然很多项目一开始就开放源代码，但是越来越多的项目是经过一定时间的开发从而到达相对成熟的阶
段或者在某个开发里程碑完成之后才开放源代码。这种最终开发源代码的方式会从Git中保留的历史记录
和在GitHub上维护的版本库中获益。关于“为何这行代码为什么这样写”的问题可以从 Git 的提交历史
记录上获得答案。同时，让项目转变为开源项目从而由 GitHub 的社会化编程中获益的操作就像在版本库
管理页面中单击布尔型切换按钮这么简单（见图21-38）。

图21-38 公开与私有版本库切换按钮
21.20 开发模型
使用Git作为VCS，或者说得更详细点，使用GitHub托管版本库，有许多使用模式。以下简述其中的三
种。
中心模型（见图21-39）仍然提供本地提交，所以并不像SVN那样的真正的中心版本库。它是最简单的
但最不吸引人的方式。这种简单的方式下，开发人员频繁地推送代码以保证“所有内容都在中心版本库
中”的原则，就像使用以前的版本控制工具一样。虽然这是一种很容易使用Git的方式，但是非常不适合
Git与GitHub提供的分布式和协作性模型。

图21-39 中心模型
下面介绍中尉指挥官模型（见图21-40）。可以发现，这种方式很像GitHub提供的合并请求。需要注意
的是，在没有GitHub之前，Git项目正是通过邮件和链接来实现这种协作模式，但是和合并请求相比，
这种方式明显很不方便。

图21-40 Linux中尉与指挥官模型
最后一种方式是很多公司使用的开源模型。在享受到开源的优点的同时，想要把它们的bug修复贡献回
去，但又要保持内部的革新，就要引入两个版本库的仲裁者。仲裁者（见图21-41），挑选版本同时将它
们推回到开源项目的公共区。这种方式被很多著名的项目使用（如红帽的JBoss Server）。

图21-41 部分开源模型
21.21 GitHub企业版
可能之前所述非常吸引人，但是你的公司有特殊的规定甚至法律禁止你们将代码存储在公共的互联网上，
而无论安全措施如何完善。这种情况的解决方案就是GitHub企业版（主页如图21-42所示）。它提供了
和公共GitHub相同的功能，但是以存储在企业内部主机中的虚拟机镜像形式存在（如图21-43中的
VirtualBox所示）。同时，GitHub企业版能够兼容许多企业已经使用的交换服务器轻量级目录访问协议
（Lightweight Directory Access Protocol，LDAP）和集中身份验证服务（Central Authentication Service，
CAS）。

图21-42 GitHub企业版主页
图21-43 VirtualBox中的GitHub企业版
21.22 关于GitHub 的总结
Git是一种版本控制工具，它已经撼动了CVS、SVN、Perforce以及ClearCase的地位。这正是因为它是
高性能、协作化和分布式的开源版本控制系统。GitHub是十分优秀的Web应用，它极大地减少了使用工
具的负担，加快了微小修改的流程，同时允许大量开发人员对一个项目做出贡献，更重要的是，它真正
使得编程成为真正社会化的活动。

version_control_git2-ptp出片.indd 1 2015.1.13 3:32:40 PM

这是一个离线工具，您的数据保留在本地，不会发送到任何服务器！
反馈和错误报告